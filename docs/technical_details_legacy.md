# lianpkg 技术文档与算法解析

本文档旨在详细解析 `lianpkg` 项目中涉及的核心文件格式（.pkg, .tex）及其解包与转换算法。本文档既适合想要了解 Wallpaper Engine 壁纸工作原理的用户，也适合想要深入研究代码实现的开发者。

## 1. Wallpaper Engine 工作机制简述

Wallpaper Engine 的壁纸主要分为两种类型：
1.  **场景壁纸 (Scene Wallpapers):** 这是最复杂的类型，通常包含 3D 模型、粒子效果、着色器和脚本。这些资源通常被打包在一个或多个 `.pkg` 文件中，以保护资源并优化加载。
2.  **视频/Web 壁纸:** 这类壁纸结构较简单，通常直接包含 `.mp4` 视频文件或 `index.html` 网页文件。

`lianpkg` 的主要目标是处理 **场景壁纸**。在这类壁纸的目录中，你通常会看到：
*   `project.json`: 描述壁纸的元数据（标题、作者、预览图等）。
*   `scene.pkg`: 打包的核心资源文件（纹理、模型、着色器代码等）。
*   其他 `.json` 文件: 描述场景的具体配置。

## 2. 涉及的文件格式

在解包过程中，我们主要关注以下几种文件：

*   **`.pkg` (Package):** 这是一个自定义的归档格式，类似于 `.zip` 或 `.tar`，但结构更简单且专用于该软件。它将多个小文件合并为一个大文件，包含文件名、偏移量和大小信息。
*   **`.tex` (Texture):** 这是 Wallpaper Engine 专用的纹理格式。它不仅仅是图片，还包含了纹理的元数据（如过滤模式、包裹模式）以及可能的 mipmap 层级。内部图像数据可能是原始像素（RGBA）、压缩纹理（DXT/BC 算法）或者是嵌入的常见图片格式（PNG/JPEG）。
*   **`.json`:** 标准的 JSON 格式，用于存储配置信息。解包后，这些文件通常是明文可读的。

## 3. 算法详细解析

本节将分步骤详细拆解 `.pkg` 解包和 `.tex` 转换的核心逻辑。

### 3.1. PKG 解包算法 (`src/unpacker/mod.rs`)

`.pkg` 文件本质上是一个简单的“文件系统镜像”，它将多个文件线性拼接在一起。

#### 步骤 1: 读取包头信息 (Header Parsing)
*   **处理对象:** `.pkg` 文件的起始字节。
*   **执行操作:**
    1.  读取一个 **字符串** (先读 4字节长度 `L`，再读 `L` 字节的 UTF-8 字符串)。这通常是 `"PKG0"` 或类似的版本标识。
    2.  读取一个 **32位整数** (`u32`)。这代表包内文件的总数量 (`file_count`)。
*   **期望输出:** 获得 `file_count` (例如: 128)，知道接下来要循环读取多少次索引。

#### 步骤 2: 解析文件索引表 (Index Table Parsing)
*   **处理对象:** 紧接在包头之后的数据块。
*   **执行操作:**
    *   开始一个循环，执行 `file_count` 次：
        1.  **读取文件名:** 读取一个字符串 (长度 + 内容)。例如 `"materials/shizuku.tex"`。
        2.  **读取偏移量:** 读取 `u32`。这是该文件数据相对于 **数据区起始点** 的偏移。
        3.  **读取大小:** 读取 `u32`。这是该文件数据的字节长度。
    *   将这些信息存储在一个列表 `entries` 中。
*   **期望输出:** 一个包含所有文件元数据的列表 `[(name, offset, size), ...]`。此时我们知道了包里有什么，在哪里，有多大。

#### 步骤 3: 数据提取与写入 (Data Extraction)
*   **处理对象:** 索引表之后的剩余所有二进制数据 (Data Block)。
*   **执行操作:**
    *   记录当前的文件指针位置为 `data_start`。
    *   遍历步骤 2 中生成的 `entries` 列表：
        1.  **定位:** 计算绝对位置 `start = data_start + offset`。
        2.  **切片:** 从原始数据中截取 `data[start .. start + size]`。
        3.  **创建路径:** 根据文件名创建对应的文件夹结构 (例如 `mkdir -p materials`)。
        4.  **写入:** 将截取的数据块原样写入到磁盘上的新文件中。
*   **期望输出:** 磁盘上生成了一个完整的文件夹结构，包含所有解包后的原始文件 (`.tex`, `.mdl`, `.json` 等)。

---

### 3.2. TEX 转换算法 (`src/tex/`)

`.tex` 文件的处理更为复杂，因为它不仅是容器，还涉及图像解码。

#### 步骤 1: 格式校验与头部读取 (Validation & Header)
*   **处理对象:** `.tex` 文件的起始 32 字节。
*   **执行操作:**
    1.  **校验 Magic 1:** 读取前 16 字节，必须为 `"TEXV0005"`。
    2.  **校验 Magic 2:** 读取次 16 字节，必须为 `"TEXI0001"`。
    3.  **读取 Header:** 解析随后的结构体，获取 `format` (格式枚举值), `flags` (标志位), `texture_width`, `texture_height` 等。
*   **期望输出:** 确认文件有效，并获得图像的基本属性（如宽 1920，高 1080，格式代码 4）。

#### 步骤 2: 图像容器解析 (Image Container Parsing)
*   **处理对象:** Header 之后的数据。
*   **执行操作:**
    1.  **读取 Magic:** 读取 16 字节字符串，如 `"TEXB0003"`。这决定了后续数据的解析版本。
    2.  **读取 Image Count:** 通常为 1。
    3.  **读取 Image Format:** (仅特定版本) 读取一个 `i32`，对应 FreeImage 库的格式枚举。
    4.  **读取 Is Video:** (仅特定版本) 读取布尔值，判断是否为 MP4 视频。
*   **期望输出:** 获得 `TexImage` 结构，知道这是否是一个视频，或者是一个特定格式的图片。

#### 步骤 3: Mipmap 数据提取与解压 (Mipmap Extraction)
*   **处理对象:** 图像容器内部的 Mipmap 数据块。
*   **执行操作:**
    1.  读取 Mipmap 数量 (通常有多层，我们只取第 0 层，即最高清晰度）。
    2.  **检查压缩:** 读取 `is_lz4_compressed` 标志。
    3.  **读取数据:** 读取压缩后的字节数据。
    4.  **解压 (如果需要):** 如果标志为真，使用 `lz4_flex` 算法将数据解压为原始二进制流。
*   **期望输出:** 获得了一块 **原始的图像数据块** (`Vec<u8>`)。这块数据可能是 PNG 文件的二进制，也可能是 DXT 压缩的纹理数据。

#### 步骤 4: 智能格式判定 (Format Determination)
*   **处理对象:** `TexHeader`, `TexImage` 和解压后的数据。
*   **执行操作:**
    这是一个优先级判断逻辑：
    1.  **是视频吗?** 检查 `flags` 的第 5 位或 `is_video_mp4` 字段。如果是，标记为 `VideoMp4`。
    2.  **是常见图片吗?** 检查 `image_format`。如果是 JPEG, PNG 等，标记为对应格式。
    3.  **是压缩纹理吗?** 如果以上都不是，回退到 `header.format`。
        *   0 -> `RGBA8888` (无压缩)
        *   4 -> `CompressedDXT5` (透明度渐变)
        *   6 -> `CompressedDXT3` (透明度突变)
        *   7 -> `CompressedDXT1` (无透明度)
*   **期望输出:** 确定了数据的 **真实身份** (MipmapFormat)。

#### 步骤 5: 最终解码与转换 (Decoding & Saving)
*   **处理对象:** 原始图像数据块 + 确定的格式。
*   **执行操作:**
    *   **分支 A: 视频/直接图片 (MP4, PNG, JPG)**
        *   数据本身就是完整的文件。直接将 `Vec<u8>` 写入磁盘，后缀名为 `.mp4`, `.png` 或 `.jpg`。
    *   **分支 B: GPU 纹理 (DXT1/3/5, RGBA)**
        *   数据是显卡直接读取的格式，人类不可读。
        *   **解码:** 使用 `texture2ddecoder` 库，根据宽、高和 DXT 算法，将数据“翻译”成标准的 RGBA 像素数组 (`[R, G, B, A, R, G, B, A, ...]`)。
        *   **编码:** 使用 `image` 库，将 RGBA 像素数组编码为标准的 PNG 图片并保存。
*   **期望输出:** 用户最终在文件夹中看到了一张可查看的 `.png` 图片或 `.mp4` 视频。

## 4. 开发者参考

### 核心依赖库
*   `lz4_flex`: 用于处理 `.tex` 文件中的 LZ4 解压。
*   `texture2ddecoder`: 用于解码 DXT/BC 系列的压缩纹理格式。
*   `image`: 用于将原始像素数据编码为 PNG 文件。
*   `byteorder`: 用于处理二进制数据的大小端读取。

### 目录结构建议
在 Rust 项目中，技术文档通常放置在：
*   项目根目录的 `docs/` 文件夹（推荐）。
*   或者直接写在 `README.md`（如果内容较少）。
*   代码注释中（使用 `///` 文档注释），可以通过 `cargo doc` 生成 HTML 文档。

对于本项目，建议将此文档保留在 `docs/technical_details.md`，并在 `README.md` 中提供链接。
